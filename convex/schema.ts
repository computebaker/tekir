import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Daily aggregated search usage per provider and type
  searchUsageDaily: defineTable({
    day: v.number(), // yyyymmdd
    provider: v.string(), // e.g., 'brave', 'duck'
    type: v.string(), // e.g., 'web', 'images', 'news'
    count: v.number(),
    totalResponseTimeMs: v.number(),
    totalResults: v.number(),
  })
    .index("by_day", ["day"]) // range queries
    .index("by_day_provider", ["day", "provider"]) // day + provider breakdown
    .index("by_day_type", ["day", "type"]) // day + type breakdown
    .index("by_day_provider_and_type", ["day", "provider", "type"]),

  // Daily token frequency from search queries (no raw queries stored)
  searchTokenDaily: defineTable({
    day: v.number(), // yyyymmdd
    token: v.string(),
    count: v.number(),
  })
    .index("by_day", ["day"]) // for ranges
    .index("by_day_token", ["day", "token"]),

  // Daily full query frequency (stores raw query string after ?q=)
  searchQueryDaily: defineTable({
    day: v.number(), // yyyymmdd
    query: v.string(),
    count: v.number(),
  })
    .index("by_day", ["day"]) // for ranges
    .index("by_day_query", ["day", "query"]),

  // Daily AI (Karakulak) usage per model
  aiUsageDaily: defineTable({
    day: v.number(), // yyyymmdd
    model: v.string(), // 'gemini', 'llama', 'mistral', 'chatgpt'
    count: v.number(),
    totalLatencyMs: v.number(),
    totalAnswerChars: v.number(),
  })
    .index("by_day", ["day"]) // for ranges
    .index("by_day_model", ["day", "model"]),
  

  // Daily API hits (privacy-safe): incremented when rate-limited call is allowed
  apiHitsDaily: defineTable({
    day: v.number(), // yyyymmdd
    count: v.number(),
  })
    .index("by_day", ["day"]),
  users: defineTable({
    name: v.optional(v.string()),
    username: v.optional(v.string()),
    email: v.string(),
    emailVerified: v.optional(v.number()), // Unix timestamp
    emailVerificationToken: v.optional(v.string()),
    password: v.string(),
    image: v.optional(v.string()),
    imageType: v.optional(v.string()),
    roles: v.optional(v.array(v.string())),
    settingsSync: v.boolean(),
    settings: v.optional(v.any()), // JSON settings
    polarCustomerId: v.optional(v.string()), // Polar.sh customer ID for subscription management
    createdAt: v.number(), // Unix timestamp
    updatedAt: v.number(), // Unix timestamp
  })
    .index("by_email", ["email"])
    .index("by_username", ["username"])
    .index("by_emailVerificationToken", ["emailVerificationToken"])
    .index("by_polarCustomerId", ["polarCustomerId"]),


  // Session tracking for rate limiting (replaces Redis)
  sessionTracking: defineTable({
    sessionToken: v.string(),
    hashedIp: v.optional(v.string()),
    // Optional stable, privacy-preserving device identifier (random id stored in first-party cookie)
    deviceId: v.optional(v.string()),
    userId: v.optional(v.id("users")),
    requestCount: v.number(),
    expiresAt: v.number(), // Unix timestamp
    isActive: v.boolean(),
  })
    .index("by_sessionToken", ["sessionToken"])
    .index("by_hashedIp", ["hashedIp"])
    .index("by_deviceId", ["deviceId"])
    .index("by_userId", ["userId"])
    .index("by_expiresAt", ["expiresAt"]),

  // Daily device-level usage to cap combined auth/anon requests per device
  deviceDailyUsage: defineTable({
    day: v.number(), // yyyymmdd
    deviceId: v.string(),
    count: v.number(),
  })
    .index("by_day_deviceId", ["day", "deviceId"]),

  
  
  // Daily recommended searches generated by AI
  recommendations: defineTable({
    // ISO date key YYYY-MM-DD
    date: v.string(),
    // Human readable date label e.g. "August 11th, 2025"
    dateLabel: v.optional(v.string()),
    // The 8 recommended search items for the day
    items: v.array(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_date", ["date"]),

  feedbacks: defineTable({
    userId: v.optional(v.id("users")),
    sessionToken: v.optional(v.string()),
    query: v.optional(v.string()),
    searchEngine: v.optional(v.string()),
    searchType: v.optional(v.string()),
    results: v.optional(v.any()),
    wikipedia: v.optional(v.any()),
    autocomplete: v.optional(v.any()),
    karakulak: v.optional(v.any()),
    liked: v.boolean(),
    comment: v.optional(v.string()),
    createdAt: v.number(),
  })
    .index("by_userId", ["userId"])
    .index("by_createdAt", ["createdAt"]),

  // Rate limiting for API endpoints
  rateLimits: defineTable({
    key: v.string(), // Format: "prefix:identifier" (e.g., "signin:session:abc123")
    count: v.number(),
    windowStart: v.number(), // Unix timestamp when current window started
    resetAt: v.number(), // Unix timestamp when the rate limit resets
    lastUpdated: v.number(), // Unix timestamp of last update
  })
    .index("by_key", ["key"])
    .index("by_windowStart", ["windowStart"]),
});
