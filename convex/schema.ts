import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Daily aggregated search usage per provider and type
  searchUsageDaily: defineTable({
    day: v.number(), // yyyymmdd
    provider: v.string(), // e.g., 'brave', 'duck'
    type: v.string(), // e.g., 'web', 'images', 'news'
    count: v.number(),
    totalResponseTimeMs: v.number(),
    totalResults: v.number(),
  })
    .index("by_day", ["day"]) // range queries
    .index("by_day_provider", ["day", "provider"]) // day + provider breakdown
    .index("by_day_type", ["day", "type"]), // day + type breakdown

  // Daily token frequency from search queries (no raw queries stored)
  searchTokenDaily: defineTable({
    day: v.number(), // yyyymmdd
    token: v.string(),
    count: v.number(),
  })
    .index("by_day", ["day"]) // for ranges
    .index("by_day_token", ["day", "token"]),

  // Daily AI (Karakulak) usage per model
  aiUsageDaily: defineTable({
    day: v.number(), // yyyymmdd
    model: v.string(), // 'gemini', 'llama', 'mistral', 'chatgpt'
    count: v.number(),
    totalLatencyMs: v.number(),
    totalAnswerChars: v.number(),
  })
    .index("by_day", ["day"]) // for ranges
    .index("by_day_model", ["day", "model"]),
  users: defineTable({
    name: v.optional(v.string()),
    username: v.optional(v.string()),
    email: v.string(),
    emailVerified: v.optional(v.number()), // Unix timestamp
    emailVerificationToken: v.optional(v.string()),
    password: v.string(),
    image: v.optional(v.string()),
    imageType: v.optional(v.string()),
    roles: v.optional(v.array(v.string())),
    settingsSync: v.boolean(),
    settings: v.optional(v.any()), // JSON settings
    createdAt: v.number(), // Unix timestamp
    updatedAt: v.number(), // Unix timestamp
  })
    .index("by_email", ["email"])
    .index("by_username", ["username"])
    .index("by_emailVerificationToken", ["emailVerificationToken"]),

  accounts: defineTable({
    userId: v.id("users"),
    type: v.string(),
    provider: v.string(),
    providerAccountId: v.string(),
    refresh_token: v.optional(v.string()),
    access_token: v.optional(v.string()),
    expires_at: v.optional(v.number()),
    token_type: v.optional(v.string()),
    scope: v.optional(v.string()),
    id_token: v.optional(v.string()),
    session_state: v.optional(v.string()),
  })
    .index("by_userId", ["userId"])
    .index("by_provider_account", ["provider", "providerAccountId"]),

  sessions: defineTable({
    sessionToken: v.string(),
    userId: v.id("users"),
    expires: v.number(), // Unix timestamp
  })
    .index("by_sessionToken", ["sessionToken"])
    .index("by_userId", ["userId"]),

  verificationTokens: defineTable({
    identifier: v.string(),
    token: v.string(),
    expires: v.number(), // Unix timestamp
  })
    .index("by_token", ["token"])
    .index("by_identifier_token", ["identifier", "token"]),

  // Session tracking for rate limiting (replaces Redis)
  sessionTracking: defineTable({
    sessionToken: v.string(),
    hashedIp: v.optional(v.string()),
    userId: v.optional(v.id("users")),
    requestCount: v.number(),
    expiresAt: v.number(), // Unix timestamp
    isActive: v.boolean(),
  })
    .index("by_sessionToken", ["sessionToken"])
    .index("by_hashedIp", ["hashedIp"])
    .index("by_userId", ["userId"])
    .index("by_expiresAt", ["expiresAt"]),

  // AI chat conversations
  chats: defineTable({
    userId: v.id("users"),
    title: v.optional(v.string()),
    model: v.optional(v.string()),
    // Messages are stored inline for simplicity; can be split later if needed
  messages: v.array(
      v.object({
        id: v.string(), // client-side uuid
        role: v.string(), // 'user' | 'assistant' | 'system' | 'tool'
        content: v.any(), // text or structured content blocks
        createdAt: v.number(), // Unix timestamp
        model: v.optional(v.string()),
        toolCalls: v.optional(v.any()),
    tokensIn: v.optional(v.number()),
    tokensOut: v.optional(v.number()),
      })
    ),
    // Optional derived threads, useful for branch conversations
    threads: v.optional(
      v.array(
        v.object({
          id: v.string(),
          title: v.optional(v.string()),
          createdAt: v.number(),
          metadata: v.optional(v.any()),
        })
      )
    ),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_userId", ["userId"])
    .index("by_userId_updatedAt", ["userId", "updatedAt"]) // for recent chats list
    .index("by_updatedAt", ["updatedAt"]),
  
  // Daily recommended searches generated by AI
  recommendations: defineTable({
    // ISO date key YYYY-MM-DD
    date: v.string(),
    // Human readable date label e.g. "August 11th, 2025"
    dateLabel: v.optional(v.string()),
    // The 8 recommended search items for the day
    items: v.array(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_date", ["date"]),

  feedbacks: defineTable({
    userId: v.optional(v.id("users")),
    sessionToken: v.optional(v.string()),
    query: v.optional(v.string()),
    searchEngine: v.optional(v.string()),
    searchType: v.optional(v.string()),
    results: v.optional(v.any()),
    wikipedia: v.optional(v.any()),
    autocomplete: v.optional(v.any()),
    karakulak: v.optional(v.any()),
    liked: v.boolean(),
    comment: v.optional(v.string()),
    createdAt: v.number(),
  })
    .index("by_userId", ["userId"]) 
    .index("by_createdAt", ["createdAt"]),
});
